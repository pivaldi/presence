package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.85

import (
	"context"
	"fmt"

	"github.com/pivaldi/presence/examples/gqlgen/graph/generated"
	"github.com/pivaldi/presence/examples/gqlgen/graph/model"
)

// UpdateUser is the resolver for the updateUser field.
// Demonstrates presence.Of[T] 3-state handling for PATCH semantics.
func (r *mutationResolver) UpdateUser(ctx context.Context, id string, input model.UpdateUserInput) (*model.User, error) {
	user, ok := r.users[id]
	if !ok {
		return nil, fmt.Errorf("user not found: %s", id)
	}

	// Username: required field, cannot be set to null
	if input.Username.IsSet() {
		if input.Username.IsNull() {
			return nil, fmt.Errorf("username cannot be null")
		}
		user.Username = input.Username.MustGet()
	}

	// Email: optional, can be set to null to clear
	if input.Email.IsSet() {
		user.Email = input.Email.Ptr()
	}

	// Bio: optional, can be set to null to clear
	if input.Bio.IsSet() {
		user.Bio = input.Bio.Ptr()
	}

	// Website: optional, can be set to null to clear
	if input.Website.IsSet() {
		user.Website = input.Website.Ptr()
	}

	// Age: optional, can be set to null to clear
	if input.Age.IsSet() {
		user.Age = input.Age.Ptr()
	}

	return user, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	user, ok := r.users[id]
	if !ok {
		return nil, nil // Return nil for not found (GraphQL nullable)
	}
	return user, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context) ([]*model.User, error) {
	users := make([]*model.User, 0, len(r.users))
	for _, u := range r.users {
		users = append(users, u)
	}
	return users, nil
}

// Username is the resolver for the username field.
func (r *updateUserInputResolver) Username(ctx context.Context, obj *model.UpdateUserInput, data *string) error {
	panic(fmt.Errorf("not implemented: Username - username"))
}

// Email is the resolver for the email field.
func (r *updateUserInputResolver) Email(ctx context.Context, obj *model.UpdateUserInput, data *string) error {
	panic(fmt.Errorf("not implemented: Email - email"))
}

// Bio is the resolver for the bio field.
func (r *updateUserInputResolver) Bio(ctx context.Context, obj *model.UpdateUserInput, data *string) error {
	panic(fmt.Errorf("not implemented: Bio - bio"))
}

// Website is the resolver for the website field.
func (r *updateUserInputResolver) Website(ctx context.Context, obj *model.UpdateUserInput, data *string) error {
	panic(fmt.Errorf("not implemented: Website - website"))
}

// Age is the resolver for the age field.
func (r *updateUserInputResolver) Age(ctx context.Context, obj *model.UpdateUserInput, data *int) error {
	panic(fmt.Errorf("not implemented: Age - age"))
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

// UpdateUserInput returns generated.UpdateUserInputResolver implementation.
func (r *Resolver) UpdateUserInput() generated.UpdateUserInputResolver {
	return &updateUserInputResolver{r}
}

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type updateUserInputResolver struct{ *Resolver }
